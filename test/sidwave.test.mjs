import test from "node:test";
import assert from "node:assert/strict";
import { compileSidwaveToPrg, compileSidwaveToSid } from "../src/sidwaveCompiler.js";
import { parseSidwave } from "../src/sidwave.js";
import { runSidToWav, SidplayExecutionError } from "../src/sidplayRunner.js";
import os from "node:os";
import fs from "node:fs";
import path from "node:path";
import { analyzePcmForTest } from "../src/audio/record_and_analyze_audio.js";

const EXAMPLE = `
# yaml-language-server: $schema=https://example.com/sidwave.schema.json
sidwave: 1.0
title: "Echoes of Tomorrow"
author: "Generated by MCP"
tempo: 92
mode: PAL
voices:
  - id: 1
    waveform: pulse
    patterns:
      A:
        type: arpeggio
        notes: [C3, E3, G3, B2]
        fx: { vibrato: { depth: 0.2, rate: 5 }, pwm_sweep: { speed: 1, depth: 64 } }
  - id: 2
    waveform: triangle
    patterns:
      B:
        groove: [C2, C2, G1, C2]
  - id: 3
    waveform: sawtooth
    patterns:
      C:
        groove: [C1, C1, C1, G0]

timeline:
  - section: Intro
    bars: 8
    layers: { v1: A, v2: B, v3: C }
`;

test("SIDWAVE: compile to PRG and SID", () => {
  const doc = parseSidwave(EXAMPLE);
  const { prg } = compileSidwaveToPrg(doc);
  assert.ok(prg instanceof Buffer);
  // PRG load address may be $0801 (BASIC header) or $0810 (direct code)
  const load = prg.readUInt16LE(0);
  assert.ok(load === 0x0801 || load === 0x0810, `Unexpected load address ${load.toString(16)}`);
  const { sid } = compileSidwaveToSid(doc, prg);
  assert.ok(sid instanceof Buffer);
  assert.equal(sid.toString("ascii", 0, 4), "PSID");
  assert.ok(sid.length >= 124 + 2, `Unexpected SID length: ${sid.length}`);
});

function parseWavPcm16(buffer) {
  // Very small parser for PCM16LE WAV files
  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  if (buffer.toString("ascii", 0, 4) !== "RIFF" || buffer.toString("ascii", 8, 12) !== "WAVE") {
    throw new Error("Not a WAV file");
  }
  let offset = 12;
  let fmt = null;
  let data = null;
  while (offset + 8 <= buffer.length) {
    const id = buffer.toString("ascii", offset, offset + 4);
    const size = view.getUint32(offset + 4, true);
    offset += 8;
    if (id === "fmt ") {
      const audioFormat = view.getUint16(offset + 0, true);
      const numChannels = view.getUint16(offset + 2, true);
      const sampleRate = view.getUint32(offset + 4, true);
      const bitsPerSample = view.getUint16(offset + 14, true);
      fmt = { audioFormat, numChannels, sampleRate, bitsPerSample };
    } else if (id === "data") {
      data = buffer.subarray(offset, offset + size);
    }
    offset += size;
  }
  if (!fmt || !data) throw new Error("Invalid WAV: missing fmt or data chunk");
  if (fmt.audioFormat !== 1 || fmt.bitsPerSample !== 16) throw new Error("Expected PCM16 WAV");
  // Downmix if stereo
  const samples = new Float32Array(data.length / 2 / fmt.numChannels);
  let outIdx = 0;
  for (let i = 0; i < data.length; i += 2 * fmt.numChannels) {
    let acc = 0;
    for (let ch = 0; ch < fmt.numChannels; ch += 1) {
      const s = data.readInt16LE(i + ch * 2);
      acc += s / 32768;
    }
    samples[outIdx++] = acc / fmt.numChannels;
  }
  return { samples, sampleRate: fmt.sampleRate };
}

test("SIDWAVE -> SID -> WAV via sidplayfp, then analyze", async (t) => {
  const tmp = fs.mkdtempSync(path.join(os.tmpdir(), "sidwave-"));
  const sidPath = path.join(tmp, "song.sid");
  const wavPath = path.join(tmp, "song.wav");

  const doc = parseSidwave(EXAMPLE);
  const { prg, entryAddress } = compileSidwaveToPrg(doc);
  const { sid } = compileSidwaveToSid(doc, prg, { entryAddress });
  fs.writeFileSync(sidPath, sid);

  try {
  const mode = (doc.mode || "ntsc").toLowerCase() === "pal" ? "pal" : "ntsc";
  const res = await runSidToWav({ sidPath, wavPath, mode, limitCycles: 6_000_000 });
    assert.equal(res.exitCode, 0);
    assert.ok(fs.existsSync(wavPath), "WAV not created");
    const stat = fs.statSync(wavPath);
    assert.ok(stat.size > 0, "WAV is empty");
    assert.equal(res.wavInfo.sampleRate, 44100, "expected 44.1kHz sample rate");
    assert.equal(res.wavInfo.bitsPerSample, 16, "expected 16-bit PCM");

    const wavBuf = fs.readFileSync(wavPath);
    const { samples, sampleRate } = parseWavPcm16(wavBuf);
    const analysis = await analyzePcmForTest(samples, sampleRate, EXAMPLE);
    assert.ok(analysis?.analysis?.voices?.[0]?.detected_notes?.length >= 1, "no notes detected in WAV analysis");
  } catch (e) {
    if (e && typeof e === "object" && (e instanceof SidplayExecutionError)) {
      if (e.exitCode === 127) {
        t.skip("sidplayfp not installed (exit 127)");
        return;
      }
      // Log diagnostics for CI analysis
      console.error("sidplayfp command:", e.command);
      if (e.stderrFirst) console.error("stderr(first):\n" + e.stderrFirst);
      if (e.stderrLast) console.error("stderr(last):\n" + e.stderrLast);
    }
    throw e;
  }
});
